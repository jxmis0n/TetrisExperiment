<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"/>
  <title>Tetris vs CPU</title>
  <style>
    /* Prevent scrolling */
    html, body { margin:0; padding:0; height:100%; overflow:hidden; }

    /* LOADING SCREEN */
    #loadingOverlay {
      position:absolute; top:0; left:0; right:0; bottom:0;
      background:#000; color:#fff;
      display:flex; flex-direction:column;
      align-items:center; justify-content:center;
      z-index:100;
    }
    #loadingText { font-size:24px; margin-bottom:20px; }
    #loadingBarBg { width:80%; height:20px; background:#444; border-radius:10px; overflow:hidden; }
    #loadingBarFg { width:0%; height:100%; background:limegreen; transition:width 0.2s linear; }

    /* COUNTDOWN */
    #countdownOverlay {
      position:absolute; top:0; left:0; right:0; bottom:0;
      background:rgba(0,0,0,0.8); color:#fff;
      font-size:100px; display:flex;
      align-items:center; justify-content:center;
      z-index:90; visibility:hidden;
    }

    /* SCORE PILL BAR & LEAD */
    #scoreBars {
      position:absolute; top:0; left:0; right:0;
      background:#eee; padding:10px 0; text-align:center; z-index:10;
    }
    .pill { display:inline-block; margin:0 10px; padding:6px 20px; border-radius:20px; font-family:sans-serif; font-size:16px; color:#fff; font-weight:bold; }
    .pill.blue { background:linear-gradient(to right,navy,blue); }
    .pill.red  { background:linear-gradient(to right,maroon,red); }
    #leadText {
      position:absolute; top:50%; left:50%;
      transform:translate(-50%,-50%) rotate(-15deg);
      font-size:32px; color:deeppink; text-shadow:0 0 8px hotpink;
      display:none; z-index:50; animation:leadShake 0.1s infinite alternate;
    }
    @keyframes leadShake { from{transform:translate(-3px,-3px) rotate(-15deg);} to{transform:translate(3px,3px) rotate(-15deg);} }

    /* TETRIS CANVASES */
    #tetrisWrapper {
      position:absolute; top:60px; bottom:160px; left:0; right:0;
      display:flex; justify-content:center; align-items:flex-start; gap:10px; padding:5px;
    } left:0; right:0;
      display:flex; justify-content:center; align-items:flex-start; gap:10px; padding:5px;
    }
    canvas { background:#000; box-shadow:0 0 8px rgba(0,0,0,0.5); width:100%; max-width:300px; height:auto; touch-action:none; }
    canvas.player { border:3px solid blue; }
    canvas.cpu    { border:3px solid red; }

    /* CONTROLS */
    #controls {
      position:absolute; bottom:0; left:0; right:0;
      display:flex; justify-content:center; gap:40px;
      font-family:sans-serif; font-size:14px;
      background:rgba(255,255,255,0.8); padding:10px 0; z-index:10;
    } left:0; right:0;
      display:flex; justify-content:center; gap:40px;
      font-family:sans-serif; font-size:14px;
      background:rgba(255,255,255,0.8); padding:10px 0; z-index:10;
    }
    #holdBox { width:80px; height:80px; border:2px solid #000; }

    /* MOBILE TOUCH BUTTONS */
    #mobileControls {
      position:absolute; bottom:0; left:0; right:0;
      display:none; justify-content:center; flex-wrap:wrap;
      gap:10px; padding:10px; background:rgba(0,0,0,0.8); z-index:10;
    }
    #mobileControls button {
      width:60px; height:60px; font-size:24px; border:none; border-radius:8px; background:#444; color:#fff;
    }

    /* TETRIS ALERT */
    #tetrisOverlay {
      position:absolute; top:40%; left:50%; transform:translate(-50%,-50%);
      font-size:48px; color:yellow; text-shadow:0 0 10px orange;
      display:none; z-index:40;
    }

    /* MOBILE LAYOUT */
    @media (max-width:600px) {
      #tetrisWrapper { flex-direction:column; }
      #controls { display:none; }
      #mobileControls { display:flex; }
    }
  </style>
</head>
<body>
  <div id="loadingOverlay">
    <div id="loadingText">Finding Opponent…</div>
    <div id="loadingBarBg"><div id="loadingBarFg"></div></div>
  </div>
  <div id="countdownOverlay">3</div>
  <div id="scoreBars">
    <div id="playerPill" class="pill blue">Player: <span id="playerScorePill">0 pts</span></div>
    <div id="cpuPill" class="pill red"><span id="cpuNamePill">CPU</span>: <span id="cpuScorePill">0 pts</span></div>
    <div id="leadText"></div>
  </div>
  <div id="tetrisWrapper">
    <canvas id="playerCanvas" class="player" width="300" height="600"></canvas>
    <canvas id="cpuCanvas"    class="cpu"    width="300" height="600"></canvas>
  </div>
  <div id="controls">
    <div id="holdBox"><canvas id="holdCanvas" width="80" height="80"></canvas></div>
    A/←=Left D/→=Right S/↓=Soft Drop Shift=Rotate Space=Hard Drop C=Hold
  </div>
  <div id="mobileControls">
    <button data-cmd="moveLeft">⟵</button>
    <button data-cmd="moveDown">⟷</button>
    <button data-cmd="moveRight">⟶</button>
    <button data-cmd="rotate">⟳</button>
    <button data-cmd="hardDrop">⤵</button>
    <button data-cmd="hold">H</button>
  </div>
  <div id="tetrisOverlay">WOW TETRIS!</div>
  <script>
  (function(){
    const p = new URLSearchParams(location.search);
    const competition = (p.get('competition')||'Low').toLowerCase();
    const valence = p.get('valence') || 'Positive';
    const round = parseInt(p.get('round')) || 1;
    const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

    const names=['Ash','Jordan','Riley','Taylor'];
    const cpuName=names[Math.floor(Math.random()*names.length)];
    document.getElementById('cpuNamePill').textContent=cpuName;

    if(isMobile && competition==='high'){
      document.getElementById('playerCanvas').style.maxWidth='90vw';
      document.getElementById('cpuCanvas').style.maxWidth='60vw';
    }
    if(isMobile && competition==='low'){
      document.getElementById('cpuCanvas').style.display='none';
    }

    let phase=0, timer=0;
    const loadOv=document.getElementById('loadingOverlay'),
          loadTxt=document.getElementById('loadingText'),
          loadFg=document.getElementById('loadingBarFg');
    const loader=setInterval(()=>{
      timer++;
      if(phase===0){
        loadFg.style.width=Math.min(100,(timer/4*25))+'%';
        if(timer>=4){ phase=1; timer=0; loadTxt.textContent='Opponent Found'; loadFg.style.width='100%'; }
      } else {
        if(timer>=1){ clearInterval(loader); loadOv.style.display='none'; startCountdown(); }
      }
    },1000);

    const cdOv=document.getElementById('countdownOverlay');
    function startCountdown(){
      let c=3; cdOv.style.visibility='visible'; cdOv.textContent=c;
      const ci=setInterval(()=>{
        c--; if(c>0) cdOv.textContent=c;
        else{ clearInterval(ci); cdOv.style.visibility='hidden'; last=performance.now(); requestAnimationFrame(frame); }
      },1000);
    }

    function getRandom(min,max){ return min+Math.random()*(max-min); }

    const SHAPES={ I:[[[1,1,1,1]],[[1],[1],[1],[1]]], O:[[[1,1],[1,1]]], T:[[[0,1,0],[1,1,1]],[[1,0],[1,1],[1,0]],[[1,1,1],[0,1,0]],[[0,1],[1,1],[0,1]]], S:[[[0,1,1],[1,1,0]],[[1,0],[1,1],[0,1]]], Z:[[[1,1,0],[0,1,1]],[[0,1],[1,1],[1,0]]], J:[[[1,0,0],[1,1,1]],[[1,1],[1,0],[1,0]],[[1,1,1],[0,0,1]],[[0,1],[0,1],[1,1]]], L:[[[0,0,1],[1,1,1]],[[1,0],[1,0],[1,1]],[[1,1,1],[1,0,0]],[[1,1],[0,1],[0,1]]] };
    const COLORS={ O:'blue', I:'purple', T:'orange', S:'pink', Z:'yellow', L:'red', J:'green', G:'gray' };
    function aggregateHeight(g){ let h=0; for(let c=0;c<10;c++){ for(let r=0;r<20;r++){ if(g[r][c]){ h+=20-r; break; }}} return h; }
    function countHoles(g){ let holes=0; for(let c=0;c<10;c++){ let seen=false; for(let r=0;r<20;r++){ if(g[r][c]) seen=true; else if(seen) holes++; }} return holes; }
    function bumpiness(g){ let heights=[]; for(let c=0;c<10;c++){ let h=0; for(let r=0;r<20;r++) if(g[r][c]){ h=20-r; break;} heights.push(h);} let b=0; for(let i=0;i<9;i++) b+=Math.abs(heights[i]-heights[i+1]); return b; }

    class TetrisBoard{
      constructor(id,mode){
        this.ctx=document.getElementById(id).getContext('2d'); this.mode=mode;
        this.grid=Array(20).fill().map(()=>Array(10).fill(0));
        this.score=0; this.garbage=0; this.hold=null; this.canHold=true;
        this.prevShape=null; this.gameOver=false; this.cpuTimer=0;
        this.ready=(mode==='human'); this.readyTimer=0;
        this.readyDelay=(mode==='cpu'? (competition==='high'? getRandom(200,500): getRandom(800,1500)):0);
        this.spawn();
        let cpuSpeed=(competition==='high'?200:1000);
        this.dropInterval=(mode==='cpu'?cpuSpeed:500);
        this.acc=0; this.last=0;
      }
      spawn(){ let ks=Object.keys(SHAPES),p; do{p=ks[Math.floor(Math.random()*ks.length)];}while(p===this.prevShape); this.prevShape=p; this.shape=SHAPES[p]; this.rot=0; this.mat=this.shape[0]; this.x=Math.floor((10-this.mat[0].length)/2); this.y=0; this.canHold=true; this.ready=(this.mode==='human'); this.readyTimer=0; if(!this.valid(this.mat,this.x,this.y)) this.gameOver=true; if(this.mode==='cpu') this.planCPU(); }
      valid(mat,x,y){ for(let r=0;r<mat.length;r++)for(let c=0;c<mat[r].length;c++)if(mat[r][c]){ let X=x+c, Y=y+r; if(X<0||X>=10||Y<0||Y>=20||this.grid[Y][X]) return false;} return true; }
      clearLines(){ let before=this.grid.length; this.grid=this.grid.filter(r=>r.some(v=>v===0)); let L=20-this.grid.length; while(this.grid.length<20) this.grid.unshift(Array(10).fill(0)); return L; }
      lock(){ for(let r=0;r<this.mat.length;r++)for(let c=0;c<this.mat[r].length;c++)if(this.mat[r][c]) this.grid[this.y+r][this.x+c]=this.prevShape; let L=this.clearLines(); if(L){ this.score+=L*100; if(competition==='high') this.garbage=L; if(competition==='high'&&L>=4) triggerTetrisAlert(); } this.spawn(); }
      move(dx,dy){ if(this.valid(this.mat,this.x+dx,this.y+dy)){ this.x+=dx; this.y+=dy; return true;} return false; }
      rotate(){ let nr=(this.rot+1)%this.shape.length, nm=this.shape[nr]; if(this.valid(nm,this.x,this.y)){ this.rot=nr; this.mat=nm; }}
      hardDrop(){ while(this.move(0,1)); this.lock(); }
      planCPU(){ let best=Infinity,plan={}; for(let r=0;r<this.shape.length;r++){ let mat=this.shape[r],w=mat[0].length; for(let x=0;x<=10-w;x++){ let y=0; while(this.valid(mat,x,y)) y++; y--; if(y<0) continue; let g=this.grid.map(rr=>rr.slice()); for(let rr=0;rr<mat.length;rr++)for(let cc=0;cc<mat[rr].length;cc++) if(mat[rr][cc]) g[y+rr][x+cc]=1; let lines=20-g.filter(row=>row.some(v=>v===0)).length; let score=aggregateHeight(g)+countHoles(g)*1.5+bumpiness(g)*0.5-lines*10; if(score<best){best=score; plan={rot:r,x,y};}}} this.cpuPlan=plan; }
      update(dt){ if(this.mode==='cpu'&&!this.ready){ this.readyTimer+=dt; if(this.readyTimer>=this.readyDelay) this.ready=true; else return; } if(this.gameOver) return; this.acc+=dt; if(this.acc>this.dropInterval){ this.acc=0; if(!this.move(0,1)) this.lock(); } if(this.mode==='cpu'&&this.cpuPlan){ this.cpuTimer+=dt; if(this.cpuTimer>800){ if(this.rot!==this.cpuPlan.rot) this.rotate(); else if(this.x<this.cpuPlan.x) this.move(1,0); else if(this.x>this.cpuPlan.x) this.move(-1,0); else { if(competition==='high') this.hardDrop(); this.cpuTimer=0; } }} }
      draw(){ let ctx=this.ctx; ctx.clearRect(0,0,300,600); for(let r=0;r<20;r++)for(let c=0;c<10;c++){ if(this.grid[r][c]){ ctx.fillStyle=COLORS[this.grid[r][c]]; ctx.fillRect(c*30,r*30,30,30);} ctx.strokeStyle='#333'; ctx.strokeRect(c*30,r*30,30,30);} if(!this.gameOver){ ctx.fillStyle=COLORS[this.prevShape]; for(let r=0;r<this.mat.length;r++)for(let c=0;c<this.mat[r].length;c++)if(this.mat[r][c]){ ctx.fillRect((this.x+c)*30,(this.y+r)*30,30,30); ctx.strokeRect((this.x+c)*30,(this.y+r)*30,30,30);} } this.drawHold(); }
      hold(){ if(!this.canHold) return; this.canHold=false; if(!this.hold){ this.hold=this.prevShape; this.spawn(); } else { let tmp=this.prevShape; this.prevShape=this.hold; this.hold=tmp; this.shape=SHAPES[this.prevShape]; this.rot=0; this.mat=this.shape[0]; this.x=Math.floor((10-this.mat[0].length)/2); this.y=0; }}
      drawHold(){ let hc=document.getElementById('holdCanvas'),ctx=hc.getContext('2d'); ctx.clearRect(0,0,80,80); if(!this.hold) return; let mat=SHAPES[this.hold][0],sz=80/mat.length; for(let r=0;r<mat.length;r++)for(let c=0;c<mat[r].length;c++)if(mat[r][c]){ ctx.fillStyle=COLORS[this.hold]; ctx.fillRect(c*sz,r*sz,sz,sz); ctx.strokeStyle='#000'; ctx.strokeRect(c*sz,r*sz,sz,sz);} }
    }

    window.player=new TetrisBoard('playerCanvas','human');
    window.cpu=new TetrisBoard('cpuCanvas','cpu');
    let last=performance.now();

    function frame(ts){ let dt=ts-last; last=ts; player.update(dt); cpu.update(dt);
      if(competition==='high'){
        while(player.garbage>0){ cpu.grid.shift(); cpu.grid.push(Array(10).fill('G')); player.garbage--; }
        while(cpu.garbage>0){ player.grid.shift(); player.grid.push(Array(10).fill('G')); cpu.garbage--; }
      }
      player.draw(); cpu.draw(); updateScores(player.score,cpu.score);
      if(!player.gameOver&&!cpu.gameOver) requestAnimationFrame(frame);
      else showChat(); }

    function updateScores(p,c){ document.getElementById('playerScorePill').textContent=p+' pts'; document.getElementById('cpuScorePill').textContent=c+' pts'; const lead=document.getElementById('leadText'); if(competition==='high'){ if(p>c&&updateScores.last!=='p'){ lead.textContent='PLAYER TAKES THE LEAD!!'; lead.style.display='block'; setTimeout(()=>lead.style.display='none',3000); updateScores.last='p'; } if(c>p&&updateScores.last!=='c'){ lead.textContent=cpuName+' TAKES THE LEAD!!'; lead.style.display='block'; setTimeout(()=>lead.style.display='none',3000); updateScores.last='c'; } } }
    updateScores.last=null;

    function triggerTetrisAlert(){ if(competition==='high'){ const to=document.getElementById('tetrisOverlay'); to.style.display='block'; setTimeout(()=>to.style.display='none',1500); } }

    function showChat(){ const box=document.createElement('div'); box.style.position='absolute'; box.style.bottom='10px'; box.style.left='50%'; box.style.transform='translateX(-50%)'; box.style.background='rgba(255,255,255,0.9)'; box.style.padding='10px'; box.style.borderRadius='8px'; box.style.fontFamily='sans-serif'; box.style.zIndex='99'; const msg=document.createElement('div'); msg.textContent= cpuName+': '+(valence==='Positive'?"Thanks for playing. That was great.":valence==='Negative'?"Lol. I beat you. You lost.":"That was something."); msg.style.marginBottom='6px'; box.appendChild(msg); const inp=document.createElement('input'); inp.type='text'; inp.placeholder='Your response…'; inp.style.fontSize='16px'; inp.style.width='300px'; box.appendChild(inp); document.body.appendChild(box); inp.focus(); inp.addEventListener('pointerdown',e=>e.stopPropagation()); inp.addEventListener('keydown',function(e){ if(e.key==='Enter'&&this.value.trim()){ window.parent.postMessage({type:'chatResponse',round:round,valence:valence,text:this.value.trim()},'*'); this.disabled=true; this.style.opacity='0.5'; }}); }

    document.addEventListener('keydown',e=>{ if(player.gameOver) return; switch(e.key){ case 'a':case'ArrowLeft':player.move(-1,0);break; case 'd':case'ArrowRight':player.move(1,0);break; case 's':case'ArrowDown':player.move(0,1);break; case ' ':player.hardDrop();break; case 'c':player.hold();break;} if(e.code==='ShiftLeft'||e.code==='ShiftRight') player.rotate(); });

    let dragStartX=null;
    playerCanvas.addEventListener('pointerdown',e=>{ if(player.gameOver) return; dragStartX=e.clientX; e.target.setPointerCapture(e.pointerId); });
    playerCanvas.addEventListener('pointermove',e=>{ if(dragStartX===null) return; let dx=e.clientX-dragStartX; let cell=playerCanvas.clientWidth/10; if(dx>cell){player.move(1,0);dragStartX=e.clientX;} if(dx<-cell){player.move(-1,0);dragStartX=e.clientX;} });
    playerCanvas.addEventListener('pointerup',e=>{ if(dragStartX!==null){ let dx=Math.abs(e.clientX-dragStartX); if(dx<5) player.rotate(); dragStartX=null;} });

  })();
  </script>
</body>
</html>
